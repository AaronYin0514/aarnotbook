# 指针和字符串

## 字符串回顾

一个字符串由一个或多个字符组成，因此我们可以用字符数组来存放字符串，不过在数组的尾部要加上一个空字符'\0'。

```c
char s[] = "mj";
```

上面的代码定义了一个字符数组s来存储字符串"mj"，系统会自动在尾部加上一个空字符'\0'。

内存分布大致如右图所示：

![](https://images0.cnblogs.com/blog/497279/201303/18114607-4486c6aa4f204f588941e933052048cc.png)

从上一篇文章中可以看出指针和数组的关系非常密切，因此我们也可以使用指针来操作字符串。

## 一、用指针遍历字符串的所有字符

```c
// 定义一个指针p
char *p;

// 定义一个数组s存放字符串
char s[] = "mj";

// 指针p指向字符串的首字符'm'
p = s; // 或者 p = &s[0];

for (; *p != '\0'; p++) {
    printf("%c \n", *p);
}
```

执行完第8行后，内存分布如右图：

![](https://images0.cnblogs.com/blog/497279/201303/18115438-47b66a7c192a43d794d1dd196ea8d0aa.png)

有了前面[指针与数组](http://www.cnblogs.com/mjios/archive/2013/03/18/2964748.html)的基础相信大家能看到第9行之后的代码了：每次遍历之前先判断p当前指向的字符是否为空字符\0，如果不是空字符，就打印当前字符，然后执行p++让指针p指向下一个字符元素。

最后的输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/18120237-07061068b04d49d98cfa33770ffa650d.png)

## 二、用指针直接指向字符串

从前面可以看出，指针确实可以指向字符串并操作字符串。不过前面的做法是：先定义一个字符串数组存放字符串，然后将数组首地址传给指针p，让p指向字符串的首字符。

### 1.我们也可以直接用指针指向一个字符串，省略定义字符数组这个步骤

```c
[[include]] <string.h>

int main()
{
    // 定义一个字符串，用指针s指向这个字符串
    char *s = "mj";

    // 使用strlen函数测量字符串长度
    int len = strlen(s);

    printf("字符串长度：%D", len);
    return 0;
}
```

### 2.我们再来看看strlen函数在string.h中的声明

```c
size_t  strlen(const char *);
```

strlen函数中的形参是指向字符变量的指针类型，在《[十、字符和字符串常用处理函数](http://www.cnblogs.com/mjios/archive/2013/03/15/2961759.html)》中我们可以将一个字符数组名传进去，这一点又说明了指针与数组的密切关系，肯定有JQ。其实，调用strlen函数时，你传一个地址给它就行了，它会从这个地址开始计算字符的个数，直到遇到空字符'\0'位置，因此传入指针变量或者数组名都可以。

其他字符串处理函数也是一样的：

```c
char  *strcpy(char *, const char *); // 字符串拷贝函数
char  *strcat(char *, const char *); // 字符串拼接函数
int  strcmp(const char *, const char *); // 字符串比较函数
```

它们的参数都是指向字符变量的指针类型，因此可以传入指针变量或者数组名。

因此printf函数依然可以正常使用：

```c
char *s = "mj";
printf("%s", s);
```

输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/18124004-3e9431b1e2124a21a7342f880391ebe7.png)

### 3.指针指向字符串的其他方式

```c
char *s;
s = "mj";
```

上面的指向方式也是正确的：先定义指针变量，再指向字符串。如果是字符数组就不允许这样做，下面的做法是错误的：

```c
char s[10]; 
s = "mj";
```

编译器肯定报第2行的错，因为s是个常量，代表数组的首地址，不能进行赋值运算。

还需要注意的是，下面的做法也是错误的：

```c
char *s = "mj"; 
*s = "like";
```

第3行代码犯了2个错误：

* 第3行代码相当于把字符串"like"存进s指向的那一块内存空间，由第1行代码可以看出，s指向的是"mj"的首字符'm'，也就是说s指向的一块char类型的存储空间，只有1个字节，要"like"存进1个字节的空间内，肯定内存溢出
* 由第1行代码可以看出，指针s指向的是字符串常量"mj"！因此是不能再通过指针来修改字符串内容的！就算是`*s = 'A'`这样"看起来似乎正确"的写法也是错误的，因为s指向的一个常量字符串，不允许修改它内部的字符。

## 三、指针处理字符串的注意

现在想将字符串"lmj"的首字符'l'改为'L'，解决方案是多种的

### 1.第一种方案

```c
// 定义一个字符串变量"lmj"
char a[] = "lmj";

// 将字符串的首字符改为'L'
*a = 'L';

printf("%s", a);
```

程序正常运行，输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/19005527-700f7d58c27c4cd58a3fcd234f1558d0.png)

### 2.应该有人能马上想到第二种方案

```c
char *p2 = "lmj";
*p2 = 'L';

printf("%s", p2);
```

看起来似乎是可行的，但这是错误代码，错在第2行。首先看第1行，指针变量p2指向的是一块字符串常量，正因为是常量，所以它内部的字符是不允许修改的。

有人可能搞蒙了，这里的第1行代码`char *p2 = "lmj";`跟第一种方案中的第2行代码`char a[] = "lmj";`不是一样的么？这是不一样的。

* `char a[] = "lmj";`定义的是一个字符串变量！
* `char *p2 = "lmj";`定义的是一个字符串常量！