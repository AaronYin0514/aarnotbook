# 数组

为了让大家更好地学习和理解数组，我们先来认识一下内存中的"地址"。

## 地址

**1.** 计算机中的内存是以字节为单位的存储空间。内存的每一个字节都有一个唯一的编号，这个编号就称为地址。凡存放在内存中的程序和数据都有一个地址，也就是说，一个函数也有自己的内存地址。

**2.** 当定义一个变量时，系统就分配一个带有唯一地址的存储单元来存储这个变量。比如：

```c
char a = 'A'; // A的ASCII值为65
int b = 66;
```

假设是在16bit环境下，系统为a、b分别分配1个字节、2个字节的存储单元。变量存储单元的第一个字节的地址就是该变量的地址。

![](https://images0.cnblogs.com/blog/497279/201303/16112919-1747f425a0e44f6ab0f3139af76ca61a.png)

可以看出，变量a的地址是ffc3；变量b的地址是ffc1。内存中存储的都是2进制数据。

**3.** 在调试过程中，我们采取打印的方式查看变量的地址：

```c
int c = 10;

// 以16进制形式输出地址
printf("16进制:%x\n", &c);

// 以10进制形式输出地址
printf("10进制:%d", &c);
```

输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/15104107-728500736b254d17b92da6d9cd67d4bd.png)

## 一、一维数组

### 1. 一维数组的定义

* 定义的形式为：

```
类型  数组名[元素个数]
```

```c
int a[5];
```

* `[]`只能放在数组名的后面，下面的都是错误写法:

```c
int[5] a; // 错误
int[] b; // 错误
```

* `[]`里面的个数必须是一个固定值，可以是常量(比如6、8)、常量表达式(比如`3+4`、`5*7`)。绝对不能使用变量或者变量表达式来表示元素个数，大多数情况下不要省略元素个数（当数组作为函数的形参和数组初始化时除外）

下面的都是正确写法：

```c
int  a[5];   // 整型常量
int  b['A'];  // 字符常量，其实就是65
int  c[3*4];  // 整型常量表达式
```

下面的都是错误写法：

```c
int a[]; // 没有指定元素个数，错误

int i = 9;
int a[i]; // 用变量做元素个数，错误
```

### 2.一维数组的存储

定义数组时，系统将按照数组类型和个数分配一段连续的存储空间来存储数组元素，如`int a[3]`占据了连续的6字节存储空间（在16位环境下，一个int类型占用2个字节）。要注意的是，数组名代表着整个数组的地址，也就是数组的起始地址。

![](https://images0.cnblogs.com/blog/497279/201303/15143646-be1fa68f32134709b61fa57306bb57f3.png)

注意：其实a不算是变量，是个常量，它代表着数组的地址。上图把a放到变量一栏是为了方便大家理解数组结构。

数组a的地址是ffc1，`a[0]`的地址是ffc1，`a[1]`的地址是ffc3，`a[2]`的地址是ffc5。因此`a == &a[0]`，即第一个元素的地址就是整个数组的地址

### 3.一维数组的初始化

* 初始化的一般形式是：

```
类型  数组名[元素个数] = {元素1, 元素2, ...};
```

```c
int a[2] = {8, 10};
```

其实相当于：

```c
int a[2];
a[0] = 8;
a[1] = 10;
```

注意的是：C语言中编译器是不会对数组下标越界进行检查的，所以自己访问数组元素时要小心

* 元素值列表可以是数组所有元素的初值，也可以是前面部分元素的初值

```c
int a[4] = {2, 5};
```

当数组为整型时，初始化未确定初值的元素，默认为0，所以上面的`a[2]`、`a[3]`都为0

* 当对全部数组元素都赋初值时，可以省略元素个数

```c
int a[] = {2, 5, 7};
```

说明数组a的元素个数是3

* 数组初始化时的赋值方式只能用于数组的定义，定义之后只能一个元素一个元素地赋值

下面的写法是错误的：

```c
int a[3]; 
a[3] = {1, 2, 3}; // 错误
a = {1, 2, 3}; // 错误
```

其实为什么是错误的写法呢？我们可以简要分析一下。

**1>** 第2行的`a[3]`代表着访问数组的第4个元素，首先这里已经是数组下标越界了；就算没有越界，给`a[3]`赋值时也应该赋一个int类型的整数，不应该是`{}`。

**2>** 第3行的a是数组名，代表着数组的地址，它是个常量！给常量赋值，那肯定错了！

### 4.一维数组与函数参数

* 一维数组的元素作为函数实参，与同类型的简单变量作为实参一样，是单向的值传递，即数组元素的值传给形参，形参的改变不影响实参

```c
// b是test函数的形参(形式参数)
void test(int b) {
    b = 9;
}

int main()
{
    int a[3];
    a[0] = 10;
    
    printf("函数调用前的a[0]：%d\n", a[0]);
    
    test(a[0]); // a[0]是test函数的实参(实际参数)

    printf("函数调用后的a[0]：%d", a[0]);
    return 0;
}
```

输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/15113301-6bb342759f5b4dd3b9d26de459dfb78f.png)

* 大家都知道，数组名代表着整个数组的地址，如果一维数组的名字作为函数实参，传递的是整个数组，即形参数组和实参数组完全等同，是存放在同一存储空间的同一个数组。这样形参数组修改时，实参数组也同时被修改了。形参数组的元素个数可以省略。

```c
// b是test函数的形参(形式参数)
void test(int b[]) { // 也可以写int b[3]
    b[0] = 9;
}

int main()
{
    int a[3];
    a[0] = 10;
    
    printf("函数调用前的a[0]：%d\n", a[0]);
    
    test(a); // a是test函数的实参(实际参数)

    printf("函数调用后的a[0]：%d", a[0]);
    return 0;
}
```

输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/15114042-a2f9aeea8e7b44d989a3b5f4bdef2d35.png)

## 二、二维数组

### 1.二维数组的定义

定义形式：

```
类型  数组名[行数][列数]
```

```c
int a[2][3]; // 共2行3列，6个元素
```

### 2.二维数组的存储

* C语言把二维数组当作是一维数组的集合，即二维数组是一个特殊的一维数组：它的元素是一维数组。例如`int a[2][3]`可以看作由一维数组`a[0]`和一维数组`a[1]`组成，这两个一维数组都包含了3个int类型的元素

![](https://images0.cnblogs.com/blog/497279/201303/15143658-9ac5ed1d9a61422aa670fc68e43d6016.png)

* 二维数组的存放顺序是按行存放的，先存放第一行的元素，再存放第2行的元素。例如`int a[2][3]的存放顺序是：a[0][0] → a[0][1] → a[0][2] → a[1][0] → a[1][1] → a[1][2]`

* 再来看看在内存中的存储情况，例如`int a[2][2]`

![](https://images0.cnblogs.com/blog/497279/201303/16114548-beb483511de24080929e1a2a828c25dc.png)

> (注意：a[0]、a[1]也是数组，是一维数组，而且a[0]、a[1]就是数组名，因此a[0]、a[1]就代表着这个一维数组的地址)

**1>** 数组a的地址是ffc1，数组`a[0]`的地址也是ffc1，即`a = a[0]`；

**2>** 元素`a[0][0]`的地址是ffc1，所以数组`a[0]`的地址和元素`a[0][0]`的地址相同，即`a[0] = &a[0][0]`;

**3>** 最终可以得出结论：`a = a[0] = &a[0][0]`，以此类推，可以得出`a[1] = &a[1][0]`

### 3.二维数组的初始化

* 按行进行初始化  

```c
int a[2][3] = { {2, 2, 3}, {3, 4, 5} };
```

* 按存储顺序进行初始化(先存放第1行，再存放第2行)  

```c
int a[2][3] = {2, 2, 3, 3, 4, 5};
```

* 对部分元素进行初始化  

```c
int a[2][3] = { {2}, {3, 4} }; 
int b[3][3] = { { }, { , , 2}, {1, 2, 3}};
```

* 如果只初始化了部分元素，可以省略行数，但是不可以省略列数  

```c
int a[][3] = {1, 2, 3, 4, 5, 6}; 
int a[][3] = {{1, 2, 3}, {3, 5}, {}};
```

有些人可能想不明白，为什么可以省略行数，但不可以省略列数。也有人可能会问，可不可以只指定行数，但是省略列数？

其实这个问题很简单，如果我们这样写：

```c
int a[2][] = {1, 2, 3, 4, 5, 6}; // 错误写法
```

大家都知道，二维数组会先存放第1行的元素，由于不确定列数，也就是不确定第1行要存放多少个元素，所以这里会产生很多种情况，可能1、2是属于第1行的，也可能1、2、3、4是第一行的，甚至1、2、3、4、5、6全部都是属于第1行的

三维乃至更多维的数组就不再提及了，大家以此类推。