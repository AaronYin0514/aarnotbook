# 指向一维数组元素的指针

前面我们已经学习了指针，如果指针存储了某个变量的地址，我们就可以说指针指向这个变量。数组及其数组元素都占有存储空间，都有自己的地址，因此指针变量可以指向整个数组，也可以指向数组元素。

## 一、用指针指向一维数组的元素

```c
// 定义一个int类型的数组
int a[2];

// 定义一个int类型的指针
int *p;

// 让指针指向数组的第0个元素
p = &a[0];

// 修改所指向元素的值
*p = 10;

// 打印第一个元素的值
printf("a[0] = %d", a[0]);
```

输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/17180653-64ffd0f6dfb540cb9bc1b6791247bc6c.png)

说明已经通过指针间接修改了数组元素的值，跟指向一个普通int类型变量是一样的。

由于数组名代表着数组的首地址，即`a == &a[0]`，因此第8行代码等价于：

```c
// 让指针指向数组的第0个元素
p = a;
```

内存分析图如下，一个指针变量占用2个字节，一个int类型的数组元素占用2个字节

![](https://images0.cnblogs.com/blog/497279/201303/17181645-10af00695c634fd4a40ae422ee34832d.png)

## 二、用指针遍历数组元素

### 1.最普通的遍历方式是用数组下标来遍历元素

```c
// 定义一个int类型的数组
int a[4] = {1, 2, 3, 4};

int i;
for (i = 0; i < 4; i++) {
    printf("a[%d] = %d \n", i, a[i]);
}
```

输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/17220506-d0989bfed6f7485b86dd63b3f2a2d6de.png)

### 2.接下来我们用指针来遍历数组元素

先定义一个指针，指向数组的第一个元素

```c
// 定义一个int类型的数组
int a[4] = {1, 2, 3, 4};

// 定义一个int类型的指针，并指向数组的第0个元素
int *p = a;
```

![](https://images0.cnblogs.com/blog/497279/201303/17221235-a5f97e04063f4a25bef22239bb2ead90.png)

p的值是`a[0]`的地址，因此，现在我们利用指针p只能访问数组的第0个元素`a[0]`，用`*p`就可取出`a[0]`的值1。要想访问其他元素，就必须拿到元素的地址，可以发现每个元素的地址差值为2，因为在16位环境下，一个int类型的变量占用2个字节。现在只是知道`a[0]`的地址值为p，怎么根据`a[0]`的地址获取其他元素的地址呢？其实非常简单，p+1就是`a[1]`的地址。注意了，这里的p+1代表着p的值加2，并不是p的值加1，比如p的值为ffc3，p+1则为ffc5，而非ffc4。依次类推，p+2就是`a[2]`的地址ffc7，p+3就是`a[3]`的地址ffc9。

#### 我先解释一下，为什么p+1代表p的值加2，而不是加1呢？

其实，p+1不一定代表p的值加2，也可能是加1、加4或者加8。究竟加多少，这跟指针的类型有关。下图是在16位环境下的情况。

![](https://images0.cnblogs.com/blog/497279/201303/17224437-a23b48a2c7e644cfbe4c3800af5bf6f8.png)

聪明的你可能已经找到规律了，因为char类型的变量要占用1字节，所以p+1代表p的值加1；float类型的变量占用4字节，所以p+1代表p的值加4。从这一点，也可以很好地说明为什么指针一定要分类型，不同类型的指针，p+1的含义是不一样的。

上述代码中的p指向了int类型的数组元素`a[0]`，所以p+1代表p的值加2。知道怎么获取其他元素的地址了，那么就可以利用指针p遍历数组元素了。

```c
// 定义一个int类型的数组
int a[4] = {1, 2, 3, 4};

// 定义一个int类型的指针，并指向数组的第0个元素
int *p = a;

int i;
for (i = 0; i < 4; i++) {
    // 利用指针运算符*取出数组元素的值
    int value = *(p+i);

    printf("a[%d] = %d \n", i, value);
}
```

注意第10行的代码，`*(p+i)`代表根据p+i的值(其实就是第i个数组元素的地址)访问对应的存储空间，并取出存储的内容(也就是取出第i个数组元素的值)，赋值给左边的value。

最后的输出效果是一样的：

![](https://images0.cnblogs.com/blog/497279/201303/17220506-d0989bfed6f7485b86dd63b3f2a2d6de.png)。

注意的是：遍历完毕后，指针变量p还是指向`a[0]`，因为p值一直没有变过，一直都是`a[0]`的地址ffc3。

补充一下，其实第10行改成下面的代码也是可以的：

```c
int value = *(a+i);
```

大家都知道，a值代表数组的首地址，也就是`a[0]`的地址ffc3。a+1则代表a的值加2，即`a[1]`的地址ffc5，也就是说，a+i代表着元素`a[i]`的地址。相信大家也能猜出来了，a+1不一定代表着a值加2，究竟加多少，取决于数组的类型。a+i的计算方法与p+i相同。

利用上面的方法遍历完数组元素后，p一直指向元素`a[0]`。其实我们也可以直接修改p的值来访问数组元素，只需要改一下第10行的代码即可

```c
// 利用指针运算符\*取出数组元素的值
int value = *(p++);
```

`p++`其实就是相当于`p = p + 1`，直接修改了p值，而且每次是加2。因此，每执行一次p++，指针p就会指向下一个数组元素。

输出结果肯定是一样的：

![](https://images0.cnblogs.com/blog/497279/201303/17220506-d0989bfed6f7485b86dd63b3f2a2d6de.png)

但是，遍历完毕后，指针变量p没有指向任何数组元素，因为一共执行了4次`p++`，最后p值为ffcb。当然，可以重新让p指向`a[0]`：`p = &a[0];`或者`p = a`;

注意，这里的写法是错误的

```c
int value = *(a++);
```

`a++`相当于`a=a+1`，数组名a是个常量！不能进行赋值运算！

## 三、指针与数组的总结

p是指针，a是一个数组

**1>** 如果p指向了一个数组元素，则`p+1`表示指向数组该元素的下一个元素。比如，假设`p = &a[0]`，则p+1表示a[1]的地址

**2>** 对于不同类型的数组元素，p值的改变是不同的。如果数组元素为int类型，p+1代表着p的值加上2(16位环境下)

**3>** 如果p的初值是`&a[0]`，那么

* p+i和a+i都可以表示元素`a[i]`的地址，它们都指向数组的第i个元素。a代表数组首地址，a+i也是地址，它的计算方法与p+i相同
* `*(p+i)`和`*(a+i)`都表示数组元素`a[i]`
* 虽然`p+i`和`a+i`都指向数组的第i个元素,但二者使用时还是有区别的。因为作为指针变量的p可以改变自身值，如`p++`,使p的值自增。而数组名a是一个代表数组首地址的常量，它的值是不能改变的，即`a++`是不合法的

**4>** 引用一个数组元素可以有两种方法:

* 下标法: 如`a[i]`
* 指针法: 如`*(p+i)` 或 `*(a+i)`

## 四、数组、指针与函数参数

1.用数组名作为函数实参时，是把实参数组的首地址传递给形参数组，两个数组共同占用同一段内存空间，这样形参数组中的元素值发生变化就会使实参数组的元素值也同时变化

```c
void change(int b[]) {
    b[0] = 10;
}

int main()
{
    // 定义一个int类型的数组
    int a[4] = {1, 2, 3, 4};

    // 将数组名a传入change函数中
    change(a);

    // 查看a[0]
    printf("a[0]=%d", a[0]);

    return 0;
}
```

change函数的形参是数组类型的，在第11行调用change函数时，将数组名a，也就是数组的地址传给了数组b。因此数组a和b占用着同一块内存空间。

输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/18000304-047bf364cb93493988a1e4f259539eff.png)

2.这种地址的传递也可以用指针来实现。函数的实参和形参都可以分别使用数组或指针。这样就有4种情况:

![](https://images0.cnblogs.com/blog/497279/201303/18000725-9b56f4263c5f44c0a162631d7d60ae99.png)

也就是说，如果一个函数的形参类型是一个数组，调用函数时，你可以传入数组名或者指针变量；

```c
void change(int b[]) {
    b[0] = 10;
}

int main()
{
    // 定义一个int类型的数组
    int a[4] = {1, 2, 3, 4};

    int *p = a;

    // 将数组名a传入change函数中
    change(p);

    // 查看a[0]
    printf("a[0]=%d", a[0]);

    return 0;
}
```

注意第1行的形参类型是个数组`int b[]`，第10行定义了指针变量p，第13行将p当做实参传入函数

如果一个函数的形参类型是一个指针变量，调用函数时，你可以传入数组名或者指针变量。

```c
void change(int *b) {
    b[0] = 10;
    // 或者*b = 10;
}

int main()
{
    // 定义一个int类型的数组
    int a[4] = {1, 2, 3, 4};

    // 将数组名a传入change函数中
    change(a);

    // 查看a[0]
    printf("a[0]=%d", a[0]);

    return 0;
}
```

注意第1行的形参类型是个指针变量`int *b`，第12行将数组名a当做实参传入函数。

由第2行可以看出，在很多情况下，指针和数组是可以相互切换使用的。但是，并不能说指针就等于数组。