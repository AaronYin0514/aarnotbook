# 预处理指令1-宏定义

## 预处理指令简介

1.C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释(比如之前使用的`#include`文件包含指令)，产生一个新的源程序(这个过程称为编译预处理),之后再进行通常的编译

2.为了区分预处理指令和一般的C语句，所有预处理指令都以符号"#"开头，并且结尾不用分号

3.预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件

4.C语言提供的预处理指令主要有：**宏定义**、**文件包含**、**条件编译**

这一讲先介绍一下宏定义，宏定义可以分为2种：不带参数的宏定义 和 带参数的宏定义。

## 一、不带参数的宏定义

### 1.一般形式

```
[[define]] 宏名 字符串
```

比如`#define ABC 10`

右边的字符串也可以省略，比如`#define ABC`

### 2.作用

它的作用是在编译预处理时，将源程序中所有"宏名"替换成右边的"字符串"，常用来定义常量。

接下来写个程序根据圆的半径计算周长

```c
[[include]] <stdio.h>

// 源程序中所有的宏名PI在编译预处理的时候都会被3.14所代替
[[define]] PI 3.14

// 根据圆的半径计radius算周长
float girth(float radius) {
    return 2 * PI *radius;
}

int main ()
{
    float g = girth(2);

    printf("周长为：%f", g);
    return 0;
}
```

在第4行定义了一个叫PI的宏，在编译预处理之后，第8行中的`2 * PI * radius`就会变成`2 * 3.14 * radius`。

输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/19231741-659fe68ee28c4c538eeb56debe2f0809.png)

### 3.使用习惯与注意

1> 宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误

2> 对程序中用双引号扩起来的字符串内的字符，不进行宏的替换操作。比如：

```c
[[define]] R 10
int main ()
{
    char *s = "Radio";
    return 0;
}
```

在第1行定义了一个叫R的宏，但是第4行中"Radio"里面的'R'并不会被替换成10

3> 在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查

```c
[[define]] I 100
int main ()
{
    int i[3] = I;
    return 0;
}
```

在做编译预处理的时候，不管语法对不对，第4行的I都会被替换为100。不过在编译的时候就会报第4行的错。

4> 宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令

```c
[[define]] PI 3.14
/*
.
.
.
.
*/
[[undef]] PI
```

PI这个宏在第1行到第8行之间是有效的，第8行后就无效了

5> 定义一个宏时可以引用已经定义的宏名

```c
[[define]] R  3.0
[[define]] PI 3.14
[[define]] L  2*PI*R
[[define]] S  PI*R*R
```

## 二、带参数的宏定义

### 1.一般形式

```
[[define]] 宏名(参数列表) 字符串
```

### 2.作用

在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换

```c
[[include]] <stdio.h>

[[define]] average(a, b) (a+b)/2

int main ()
{
    int a = average(10, 4);

    printf("平均值：%d", a);
    return 0;
}
```

 第3行中定义了一个带有2个参数的宏average，第7行其实会被替换成：int a = \(10 + 4\)/2;，输出结果为：

![](https://images0.cnblogs.com/blog/497279/201303/19233416-bc4c16a577c7406688476517365d1810.png)。

是不是感觉这个宏有点像函数呢？

### 3.使用注意

1> 宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串

```c
[[define]] average (a, b) (a+b)/2

int main ()
{
    int a = average(10, 4);
    return 0;
}
```

注意第1行的宏定义，宏名average跟(a, b)之间是有空格的，于是，第5行就变成了这样：

```c
int a = (a, b) (a+b)/2(10, 4);
```

这个肯定是编译不通过的

2> 带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。

下面定义一个宏D(a)，作用是返回a的2倍数值：

* 如果定义宏的时候不用小括号括住参数

```c
[[include]] <stdio.h>

[[define]] D(a) 2*a

int main ()
{
    int b = D(3+4);

    printf("%d", b);
    return 0;
}
```

第7行将被替换成`int b = 2*3+4;`输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/19235531-e435f016fca2473e9b6a4309dabe6e87.png)

* 如果定义宏的时候用小括号括住参数，把上面的第3行改成：

```c
[[define]] D(a) 2*(a)
```

注意右边的a是有括号的，第7行将被替换成`int b = 2\*\(3+4\);`，输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/19235741-583de2c6bb3c440ba01f7d1583f7fc2a.png)

3> 计算结果最好也用括号括起来

下面定义一个宏`P(a)`，作用是返回a的平方：

* 如果不用小括号括住计算结果

```c
[[include]] <stdio.h>

[[define]] Pow(a) (a) * (a)

int main(int argc, const char * argv[]) {
    int b = Pow(10) / Pow(2);

    printf("%d", b);
    return 0;
}
```

注意第3行，没有用小括号扩住计算结果，只是括住了参数而已。第6行代码被替换为：

```c
int b = (10) * (10) / (2) * (2);
```

简化之后：

```c
int b = 10 * (10 / 2) * 2;
```

最后变量b为：

![](https://images0.cnblogs.com/blog/497279/201303/24194004-90038bcac5d24907a7836552159f2993.png)

* 如果用小括号括住计算结果

将上面的第3行代码改为：

```c
[[define]] Pow(a) ( (a) * (a) )
```

那么第6行被替换为：

```c
int b = ( (10) * (10) ) / ( (2) * (2) );
```

简化之后：

```c
int b = (10 * 10) / (2 * 2);
```

最后输出结果：

![](https://images0.cnblogs.com/blog/497279/201303/24194309-a5a88e1dabbc4925894684ac12da22cd.png)。

这个才是我们想要的结果。

也就意味着前面的

```c
[[define]] average(a, b) (a+b)/2
```
应该写成

```c
[[define]] average(a, b) (((a)+(b))/2)  
```

### 5.与函数的区别

从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：

1> 宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题

2> 函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率